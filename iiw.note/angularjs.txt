angular.js笔记

关于ng-app等初始程序知识点放在最后面，请滚到底部查看

内置指令
ng-show和ng-hide用来显隐元素的
ng-class 动态为元素绑定类，三种绑定方式
  对象，属性名为类名，属性值为布尔值，也可以用表达式的结果true或false
{red: x>3, green: x<=3}
变量，变量可以插入多个类，通过空格隔开
举例：$scope.activeClass = 'red green yellow'，
渲染后：class="red green yellow"
数组，数组的每个成员表示一个类
ng-style 动态为元素添加样式
对象：{color: x.status === -1 ? '#f0ad4e' : x.status === 1?'#5cb85c':x.status === 2?'#f04124':'#a5a5a5'}
变量：变量就是一个对象，就是把上面第一种方式拿到js中
ng-if 条件模板指令，跟vue不同，没有ng-else
ng-switch 多分支条件模板判断指令，指令根据表达式显示或隐藏对应的部分
对应的子元素使用 ng-switch-when 指令，如果匹配选中选择显示，其他为匹配的则移除。ng-switch-default 指令设置默认选项，如果都没有匹配的情况，默认选项会显示。
<element ng-switch="expression">
<element ng-switch-when="value"></element>
<element ng-switch-when="value"></element>
<element ng-switch-when="value"></element>
<element ng-switch-default></element>
</element>
ng-repeat 循环模板指令ng-repeat="(key, type) in record.types track by key"
$index索引值$first第一次$last最后一次$middle中间$even偶数次$odd奇数次
ng-include 指令用于包含外部的 HTML 文件 ng-include="'myFile.html'"
ng-事件 在dom中定义该事件,再到js里调用该回调函数，想传递事件对象用$event
ng-href 动态为a标签创建href属性
ng-src 动态为img标签创建src属性

过滤器 是一种对插入的数据进行处理的方法，比如常用的时间格式转换，可多次过滤器，多个过滤器之间用 | 隔开
在过滤器或者自定义过滤器，所传参数可以是一个值，或者作用域的变量或者作用域中的方法(方法的话后面不要加上( )括号)
内置过滤器
Json 将对象转化json字符串
Uppercase 字符串转大写字母
Lowercase 字符串转小写字母
Date 格式化日期
Number 对数字做处理，对整数部分，每三位加逗号，方便阅读，添加可读性
对小数部分，做截取，最后一位四舍五入，默认截取三位，这个过滤器参数表示小数的截取位数
limitTo 截取字符串或者数组，参数表示截取位数
Filter 过滤器的（类似es6的filter）
参数可以是字符串，判断数组每个成员是否包含该字符串
参数可以是变量，会根据作用域中该变量的值进行过滤
参数可以是函数，后面如果有( )表示 返回值，相当于一个变量
如果后面没有( )，这个函数是一个处理函数
orderBy 对数组排序，第一个参数表示排序字段，
第二个参数表示正序还是倒序，默认正序
Currency 金钱转换，将数字转换为一个美元格式的，前面加上$

自定义过滤器
App.filter 两个参数，第一个参数表示过滤器的名称，第二个参数表示处理函数，函数分为：
第一级函数：作用域是一个空对象，没有参数，返回值就是第二级函数
第二级函数：作用域是window，返回值为过滤后的输出数据，
第二级函数第一个参数表示处理的数据，从第二个参数开始表示，使用过滤器时候传递的参数

脏值检测（表单验证）
表单元素 name 属性会映射到作用域上，Form 元素 name 属性会直接映射到作用域上，Input 等表单元素 name 属性会映射到 form 元素对应变量上。

每一个变量会有四个特殊属性，他们的组合可以表达我们表单是否可以验证成功
$dirty 表单是否已经输入（true表示已输入）
$pristine 表单是否没有输入过（true表示没输入）
$valid 表单内容是否合法（true表示合法）
$invalid 表单内容是否不合法（true表示不合法）

还有另外一些表单验证属性
ng-required="true" 必填项
ng-maxlength="11"，ng-minlength 长度检测
ng-pattern="^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$" 正则检测
ng-disabled 表单是否可操作
ng-readyonly 表单是否只读
ng-checked 表单是否被选中
ng-change 为表单元素绑定一个change事件，必须绑定ng-model，而且无法获取事件对象，即使传递 $event 也无法获取
ng-submit 表单提交事件

自定义指令
首先在js中通过 directive 方法创建自定义指令，然后再dom中调用
directive 方法
第一个参数为自定义指令的名称（这里用驼峰式命名，页面中用-）
第二个参数是处理函数：参数是空数组，因此想使用什么服务就要传递什么服务，作用域是window，返回值是一个对象，描述自定义指令的对象，这个函数只执行一次。app.directive(name,function(){return {} })
该自定义指令返回值对象可以有一下属性设置：
restrict 定义类型，有四种类型 ECMA，举例自定义指令 my-directive
E 自定义元素，语法：<my-directive></my-directive>
C 类的自定义指令，语法：<div class="my-directive"></div>
M 注释指令，语法：<!-- directive: my-directive -->
A 属性指令，语法：<div my-directive></div>
template 定义内部模板，值为字符串，在字符串中我们可以使用angular指令，也可以使用插值语法等等
templateUrl 定义外部模板
replace 是否替换该元素（dom中的元素是否删除），true的话会用模板内容替换指令元素，flase会将模板内容插入到指令元素内
transclude 将自定义指令上的已知内容插入到模板中（与replace类似），故必须要与模板配合使用，使用方法是将设置transclude:true，然后在模板内容想插入的位置那里加上ng-transclude指令
controller方法 为自定义指令定义一个控制器，在控制器中通常会创建一个作用域
controller: function($scope,$element,$attrs){}
$scope 提供做作用域服务 
$element 提供获取元素的服务，如果没有引入jquery，这个元素是 jqlite对象，如果引入jq，这个元素是 jquery 实例化对象
$attrs 提供获取自定义指令元素上属性的服务，
对象上每一个属性对应一个指令元素上的属性（通过驼峰式命名处理的属性名称），对象上属性值就是指令元素上的属性值
$attr 表示指令元素上的真实属性名称，是对$attrs的映射
scope 隔离作用域配置，值有三种配置
scope:true，此时自定义指令的作用域是独立的，不会受到父作用域的影响
scope:false（默认），此时数据双向绑定，会互相影响
scope:{} ，为模板作用域，此时自定义指令会创建一个独立的作用域，并且根据是否有模板template属性而决定作用域效果，有template时效果为scope:true，没有template时效果为scope:false
作用域修饰符，跟vue中props属性很像，在angularjs中，想使用父作用域中的数据，可以通过属性的传递方式来实现
@修饰符：实现父作用域向子作用域传递数据并覆盖的一种方式（单向的）
<my-directive msg-data="{{msg}}"></my-directive> // 注意需用{{}}插值符号
scope:{msg: '@msgData'}
=修饰符：实现父作用域与子作用域数据的一个双向绑定，这里子作用域数据会覆盖父作用域数据，以子作用域数据为准
<my-directive msg-data="msg"></my-directive> // 注意不需用{{}}插值符
scope:{msg: '=msgData'}
link方法：对自定义指令的编译功能方法。即该自定义指令的具体功能实现。
有三个参数：link: function(scope,element,attrs){}
scope:作用域；jqlite:获取自定义指令元素jqlite对象；attrs:指令元素上的属性对象
compile方法：对指令模板DOM进行转换。
compile:function(jqlite, attrs, transclude){return function(scope,jqlite,attrs){}}
同link方法一样的作用效果，在link前面执行。这两个方法不可同时使用。
angularjs指令中的compile与link函数的区别：https://www.jianshu.com/p/e10ba0927ef1
require 为自定义指令添加依赖服务集合，值为一个数组，将多个服务传递进来，
当添加这个属性的时候，link函数会增加第四个参数来表示它，如果依赖服务只有一个，可以不用数组直接书写，此时link方法第四个参数就是该服务
require:['ngModel']，一个时也可这样写require: 'ngModel'

服务：是给控制器使用的（这一类服务是需要参数注入的），服务是在js中使用的，服务就是封装的一组功能
内建服务
$timeout服务，封装setTimeout方法，实现定时器功能。为什么要用这个，因为一般异步操作，会造成作用域丢失。即在作用域中绑定新的数据，没有渲染到页面中，这种问题就叫做作用域丢失。
解决作用域丢失问题方法有四种：
方法一：$timeout(function(){}, 1000)
方法二：通过$digest()方法进行作用域检测，只能检测在该方法调用的前面的数据。$rootScope.date = '11月20日'; $rootScope.$digest();
方法三：通过$apply()方法进行检测，效果同$digest()方法一样
方法四：通过$apply 传递回调函数，在回调函数中修改作用域，该方法前面一级回调函数内数据没有丢失，在$apply()方法后面的数据丢失了。
$rootScope.$apply(function(){$rootScope.date = '11月20日';});

$location 返回当前页面的 URL 地址：$scope.myUrl = $location.absUrl();
$http服务： 服务向服务器发送请求，应用响应服务器传送过来的数据。
$http.get("welcome.htm").then(function (response) {
$scope.myWelcome = response.data;
});
$interval 循环计时器服务
$interval(function(){console.log(111)},1000)
$watch 方法，可以实现对属性值的监听。
$scope.$watch('name',function(newValue, oldValue){})，当要监听对象里的每一个属性变化时，要加上第三个参数true
$scope.$watch('obj',function(newValue, oldValue){},true)

五种服务用法
constant服务：app.constant('name',obj)
name为服务的名字,obj为一个对象。
举例：app.constant('APP_KEY','a1s2d3f4')
constant 用于定义常量，一旦定义就不能被改变。可以被注入到任何地方，但是不能被装饰器(decorator)装饰。

value服务：app.value('name',obj)
name为服务的名字,obj为一个对象。
举例：app.value('version', '1.0')
与 constant 一样，可以用来定义值。但与 constant 的区别是：可以被修改，可以被 decorator 装饰，不能被注入到 config 中。

factory服务：app.factory('name',function(){return obj})
name为服务的名字,第二个参数传入一个函数,函数需要有一个返回值obj,返回一个对象。实际被注入的服务就是这个对象。
app.factory('myFactory', function () {
var fac = {};
fac.a = 'hello world';
fac.foo = function () {};
return fac;
})
factory服务是最常见最常用的服务类型,几乎可以满足90%的自己开发的需求,使用它可以编写一些逻辑,通过这些逻辑最后返回所需要的对象. 它和constant,value最大的区别是,factory服务是有一个处理过程,经过这个过程,才返回结果的.
factory 是一个函数用于返回值,通常我们使用 factory 函数来计算或返回值。(factory使用上，与service差距不大)

service服务：app.service('name',constructor)
name为服务的名字,constructor是一个构造函数。
app.service('myService', function () {
var a = '';
this.setA = function () {};
this.getA = function () {};
this.foo = function () {};
})
service和factory的区别在于,它第二个参数传入的是一个构造函数,最后被注入的服务是这个构造函数实例化以后的结果.所以基本上使用service创建的服务的,也都可以使用factory来创建。

provider服务：app.provider('name',function(){})
name为服务的名字,第二个参数接受一个函数,函数由两部分组成。第一部分的变量和函数是可以在 app.config 函数中访问的。第二部分的变量和函数是通过 $get() 函数返回的
app.provider('myProvider', function () {
var a = '';
var func = function () {};
return {
$get: function () {
foo: function () {},
a: a
}
}
})
$get方法就相当于factory服务的第二个参数,最后要返回一个对象,这个对象就是真正被注入的服务。

怎么选择这些服务的使用？
一些固定的参数和方法,使用constant
可能被修改的参数和方法,使用value
通过逻辑处理后得到的参数或方法,使用factory
可以使用factory的也可以使用service,反之亦然(一般就是用factory)
可以手动配置参数的服务,使用provider


ng-app 定义页面中应用程序
ng-model 做双向绑定的
ng-init 定义作用域中初始化变量值的，属性值可以定义多个变量，通过分号;间隔
ng-bind 对dom绑定内容的数据（插值）；另一种插值方式为 {{}}
Angular.module 获取页面中应用程序的，第一个参数是应用程序的名称，ng-app的值；第二个参数是一个依赖集合，默认如果没有依赖集合，要传递一个[]
ng-controller 定义控制器（创建一个作用域），写在html（即view层）
App.controller 控制器逻辑，写在js里，
第一个参数表示控制器名称，
第二个参数表示处理函数或者数据逻辑（即model层），作用域是一个空对象，默认是没有参数的，如果我们想使用作用域就要传递作用域参数$scope
参数注入：在一个函数中，我们想使用哪个模块，哪个功能，哪个服务，我们就传递哪些模块，功能，服务（注意在angularjs中这些功能模块都称之为服务）
$scope 定义angularjs中的作用域，它本质上是一种内置的服务(预使用先注入)

作用域
Run 是应用程序的执行（启动）方法，当该方法执行之后，应用程序启动起来，在该方法中我们可以使用根作用域 $rootScope
ng-controller 控制器指令，作用是用来创建作用域的
作用域基于原型式继承
1、子作用域通过继承可以使用父作用域中的数据
2、父作用域不能使用子作用域中的数据（原型式模式是单向的）
3、子作用域中定义一个与父作用域相同的变量，子作用域就不会再使用父作用域中的变量，并且也会影响到作用域中的变量，这一现象称之为覆盖
作用域对象
$parent 表示父作用域
下面这三个工作中尽量不要使用
$$childScope 表示子作用域
$$nextSibling 下一个兄弟作用域
$$pervSibling 前一个兄弟作用域












